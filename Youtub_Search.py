import os
import asyncio
import logging
import time
import json
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton
from aiohttp import ClientTimeout
from aiogram.client.session.aiohttp import AiohttpSession
from subprocess import run
from aiogram.client.telegram import TelegramAPIServer
from yt_dlp import YoutubeDL
from mega import Mega
from dotenv import load_dotenv
import subprocess
from transformers import GPT2Tokenizer, GPT2LMHeadModel

load_dotenv()

BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
MEGA_EMAIL = os.getenv('MEGA_EMAIL')
MEGA_PASSWORD = os.getenv('MEGA_PASSWORD')
FFMPEG_PATH = os.getenv('FFMPEG_PATH')

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

dp = Dispatcher()

# Load the GPT-2 model and tokenizer for generating responses
model = GPT2LMHeadModel.from_pretrained("gpt2")
tokenizer = GPT2Tokenizer.from_pretrained("gpt2")

# Function to save user input and AI response to a file
def save_user_input_to_file(user_input, ai_response):
    """
    Saves the user's input and the AI's response to a JSON file for future reference.

    Parameters:
        user_input (str): The input provided by the user.
        ai_response (str): The response generated by AI.
    """
    data = {"user_input": user_input, "ai_response": ai_response}
    with open("user_conversations.json", "a") as file:
        json.dump(data, file)
        file.write("\n")

# Function to generate AI response using GPT-2 model
def generate_response(user_input: str) -> str:
    """
    Generates a response based on the user's input using GPT-2 model.

    Parameters:
        user_input (str): The input provided by the user.

    Returns:
        str: The AI-generated response.
    """
    inputs = tokenizer.encode(user_input + tokenizer.eos_token, return_tensors="pt")
    outputs = model.generate(inputs, max_length=150, num_return_sequences=1, no_repeat_ngram_size=2, temperature=0.7)
    response = tokenizer.decode(outputs[0], skip_special_tokens=True)
    save_user_input_to_file(user_input, response)
    return response

# Function to get video resolution using ffmpeg
def get_video_resolution(file_path):
    """
    Extracts the resolution of a video file using ffmpeg.

    Parameters:
        file_path (str): The path to the video file.

    Returns:
        str: The resolution of the video, e.g., "1920x1080", or None if not found.
    """
    result = subprocess.run(
        [FFMPEG_PATH, '-i', file_path],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    for line in result.stderr.splitlines():
        if "Video:" in line:
            resolution = [s for s in line.split() if 'x' in s]
            if resolution:
                return resolution[0]  # Example: 1920x1080
    return None

# Function to scale video to the target resolution while maintaining aspect ratio
def scale_video(input_file, output_file, target_resolution):
    """
    Scales a video to a target resolution while maintaining the aspect ratio.

    Parameters:
        input_file (str): The path to the input video file.
        output_file (str): The path to save the scaled video.
        target_resolution (str): The target resolution, e.g., "1280x720".
    """
    width, height = map(int, target_resolution.split('x'))
    subprocess.run([
        FFMPEG_PATH, '-i', input_file,
        '-vf', f"scale={width}:{height}:force_original_aspect_ratio=decrease,pad={width}:{height}:(ow-iw)/2:(oh-ih)/2",
        '-c:v', 'libx264', '-c:a', 'aac', '-strict', 'experimental',
        output_file
    ])

# Predefined video resolutions
TARGET_QUALITIES = {
    '360p': '640x360',
    '480p': '854x480',
    '720p': '1280x720',
    '1080p': '1920x1080'
}

# Login to MEGA using provided credentials
mega = Mega()
m = mega.login(email=MEGA_EMAIL, password=MEGA_PASSWORD)

# Function to create an inline keyboard for selecting video quality
def get_quality_keyboard(qualities):
    """
    Creates an inline keyboard with buttons for selecting video quality.

    Parameters:
        qualities (list): A list of available video qualities (e.g., ["360p", "720p"]).

    Returns:
        InlineKeyboardMarkup: The inline keyboard for Telegram.
    """
    if not qualities:
        logger.error("No available qualities provided.")
        return None

    buttons = [
        [InlineKeyboardButton(text=quality, callback_data=f"quality_{idx}")]
        for idx, quality in enumerate(qualities)
    ]
    buttons.append([InlineKeyboardButton(text="‚ùå Cancel", callback_data="cancel")])

    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    return keyboard

# Function to process the video and audio for the final output file
def process_video_with_aspect_ratio(filename_video, filename_audio, final_video_filename, target_resolution="1920x1080"):
    """
    Processes video and audio files to create a final video file with the desired resolution.

    Parameters:
        filename_video (str): The path to the video file.
        filename_audio (str): The path to the audio file.
        final_video_filename (str): The path to save the final video.
        target_resolution (str): The target resolution for the final video, default is "1920x1080".
    """
    width, height = map(int, target_resolution.split('x'))
    run([
        FFMPEG_PATH, '-i', filename_video, '-i', filename_audio,
        '-vf', f'scale={width}:{height}:force_original_aspect_ratio=decrease,pad={width}:{height}:(ow-iw)/2:(oh-ih)/2',
        '-c:v', 'libx264', '-c:a', 'aac', '-strict', 'experimental',
        '-shortest', final_video_filename
    ])

# User state class to track user actions in the FSM
class UserState(StatesGroup):
    wait_link_or_query = State()  # Waiting for link or search query
    wait_quality_choice = State()  # Waiting for video quality choice
    wait_ai_query = State()  # Waiting for AI query input

# Command handler for the /start command
async def on_start(message: types.Message):
    """
    Handles the /start command and displays a menu for the user.

    Parameters:
        message (types.Message): The message object from the user.
    """
    keyboard = InlineKeyboardMarkup(row_width=2)
    button_1 = InlineKeyboardButton(text="Download YouTube video", callback_data="download_video")
    button_2 = InlineKeyboardButton(text="Ask AI for information", callback_data="ask_ai")
    keyboard.add(button_1, button_2)
    await message.answer("üëã Hi! I can help you with two actions. Choose one:", reply_markup=keyboard)

# Function to request link or search query from the user
async def get_video_by_link_or_query(message: types.Message, state: FSMContext):
    """
    Asks the user to send a YouTube video link or a search query.

    Parameters:
        message (types.Message): The message object from the user.
        state (FSMContext): The FSM context to track the user's state.
    """
    await message.answer("üì• Please send a YouTube video link or a search query (e.g., 'cat videos' or 'tech reviews').")
    await state.set_state(UserState.wait_link_or_query)

# Function to handle user input and fetch video or query
async def get_link_or_query(message: types.Message, state: FSMContext):
    """
    Processes the user's input, either a link or search query, to find a video.

    Parameters:
        message (types.Message): The message object from the user.
        state (FSMContext): The FSM context to track the user's state.
    """
    query_or_url = message.text.strip()
    await message.answer("‚è≥ Checking your request, please wait...")

    try:
        # If the input is a URL
        if "youtube.com" in query_or_url or "youtu.be" in query_or_url:
            url = query_or_url
        else:
            # If it's a search query, use yt-dlp to search for a video
            ydl_opts_search = {
                'quiet': True,
                'format': 'best',
                'noplaylist': True,
                'extract_flat': True,  # Only fetch metadata, not download the video
            }
            with YoutubeDL(ydl_opts_search) as ydl:
                info = ydl.extract_info(f"ytsearch:{query_or_url}", download=False)
                url = info['entries'][0]['url']  # Take the first video from the search
                logger.info(f"Found video for query: {url}")

        # Fetch video information and available qualities
        ydl_opts = {
            'quiet': True,
            'format': 'best',
            'noplaylist': True,
            'extract_audio': True,
            'outtmpl': 'downloads/%(id)s.%(ext)s',
        }
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            formats = info['formats']
            available_qualities = [f"{f['height']}p" for f in formats if f.get('height')]

        # Send a quality selection keyboard
        keyboard = get_quality_keyboard(available_qualities)
        await message.answer("üé¨ Please choose the video quality:", reply_markup=keyboard)
        await state.set_state(UserState.wait_quality_choice)

    except Exception as e:
        logger.error(f"Error processing video: {e}")
        await message.answer("‚ùå Something went wrong while processing your request. Please try again later.")
        await state.clear()

# Function to handle AI query input from the user
async def ai_query_handler(callback_query: types.CallbackQuery, state: FSMContext):
    """
    Prompts the user to input a query for the AI.

    Parameters:
        callback_query (types.CallbackQuery): The callback query object from the user.
        state (FSMContext): The FSM context to track the user's state.
    """
    await callback_query.answer()
    await callback_query.message.answer("ü§ñ Please type your question for the AI.")
    await state.set_state(UserState.wait_ai_query)

# Function to handle the AI response
async def handle_ai_query(message: types.Message, state: FSMContext):
    """
    Generates a response for the user's AI query.

    Parameters:
        message (types.Message): The message object containing the user's query.
        state (FSMContext): The FSM context.
    """
    user_input = message.text.strip()
    ai_response = generate_response(user_input)
    await message.answer(f"AI: {ai_response}")
    await state.clear()

# Function to handle video quality choice
async def quality_choice(callback_query: types.CallbackQuery, state: FSMContext):
    """
    Handles the user's choice of video quality.

    Parameters:
        callback_query (types.CallbackQuery): The callback query from the user.
        state (FSMContext): The FSM context to track the user's state.
    """
    quality = callback_query.data.split("_")[1]  # Extract quality choice from the callback data
    await callback_query.answer()
    await callback_query.message.answer(f"üé¨ You selected {quality} quality.")

    # Example: Download video with the selected quality
    await callback_query.message.answer("‚è≥ Downloading the video... Please wait.")
    
    # Proceed to download and process the video
    video_url = 'https://www.youtube.com/watch?v=dQw4w9WgXcQ'  # Replace with actual URL
    video_filename = 'downloads/video.mp4'
    audio_filename = 'downloads/audio.mp3'

    # Assume we download and process the video here
    process_video_with_aspect_ratio(video_filename, audio_filename, final_video_filename="downloads/final_video.mp4")

    # Upload video to Mega and send to user
    file = m.upload("downloads/final_video.mp4")
    video_link = m.get_link(file)
    await callback_query.message.answer(f"Here's your video: {video_link}")

# Main function to start the bot
async def main():
    bot = Bot(token=BOT_TOKEN, session=AiohttpSession())
    dp = Dispatcher(bot)
    dp.include_router(on_start)
    dp.include_router(get_video_by_link_or_query)
    dp.include_router(get_link_or_query)
    dp.include_router(ai_query_handler)
    dp.include_router(handle_ai_query)
    dp.include_router(quality_choice)

    await dp.start_polling()

# Run the bot
if __name__ == "__main__":
    asyncio.run(main())
